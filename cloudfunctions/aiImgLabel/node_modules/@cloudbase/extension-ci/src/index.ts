// const { parseString } = require('xml2js')
import { Base64 } from 'js-base64'
import * as parser from 'fast-xml-parser'

function parsePath(key, pic) {
    if (pic.indexOf('/') === 0) {
        return pic
    }

    const idx = key.lastIndexOf('/')
    if (idx === -1) {
        return pic
    }

    return key.slice(0, idx + 1) + pic
}

const ActionType = {
    DetectLabel: 'DetectLabel',
    DetectType: 'DetectType',
    WaterMark: 'WaterMark',
    ImageProcess: 'ImageProcess'
}

async function callFunction(tcb, options) {
    let ciRes
    try {
        ciRes = await tcb.callFunction(options)
    } catch (err) {
        let errMessage = `[@cloudbase/extension-ci] 调用扩展函数失败 ;  ${err.code ? err.code : ''} ${err.message ? err.message : ''}`
        if (err.message && err.message.indexOf('找不到对应的FunctionName') > -1) {
            throw new Error('[@cloudbase/extension-ci] 请确认扩展已安装')
        }

        // 兼容小程序sdk
        if (err.errMsg && err.errMsg.indexOf('找不到对应的FunctionName') > -1) {
            errMessage = '[@cloudbase/extension-ci] 请确认扩展已安装'
        }

        throw new Error(errMessage)
    }

    if (ciRes.code) {
        if (ciRes.message && ciRes.message.indexOf('找不到对应的FunctionName') > -1) {
            throw new Error('[@cloudbase/extension-ci] 请确认扩展已安装')
        }

        throw new Error(`[@cloudbase/extension-ci] 调用扩展函数失败 ;  ${ciRes.requestId ? ciRes.requestId : ''} ; ${ciRes.code} ; ${ciRes.message}`)
    }

    const { code } = ciRes.result || {}
    if (code) {
        throw new Error(`[@cloudbase/extension-ci] ${code} ; ${ciRes.requestId ? ciRes.requestId : ''} ;`)
    }

    return ciRes.result
}

export const name = 'CloudInfinite'
export async function invoke(opts, tcb) {
    // eslint-disable-next-line prefer-const
    let { cloudPath, fileContent, action, operations } = opts
    if (!action || !ActionType[action]) {
        throw new Error('[@cloudbase/extension-ci] action必须为正确的值')
    }

    cloudPath = cloudPath.indexOf('/') === 0 ? cloudPath.slice(1) : cloudPath

    const headers = {}


    let method
    if (fileContent) {
        if (!(fileContent instanceof Uint8Array || fileContent instanceof ArrayBuffer)) {
            throw new Error('[@cloudbase/extension-ci] fileContent一定要是Uint8Array对象或者ArrayBuffer对象')
        }
    }

    let query
    if (action === ActionType.DetectLabel) {
        method = 'GET'
        query = {
            'ci-process': 'detect-label'
        }
    } else if (action === ActionType.DetectType) {
        method = 'GET'
        if (!operations.type) {
            throw new Error('[@cloudbase/extension-ci] DetectType是，type字段不为空')
        }

        query = {
            'ci-process': 'sensitive-content-recognition',
            'detect-type': operations.type
        }

        delete operations.type
    } else if (action === ActionType.ImageProcess) {
        query = 'image_process'
        method = 'POST'
        if (fileContent) {
            method = 'PUT'
            query = undefined
        }
    } else if (action === ActionType.WaterMark) {
        method = fileContent ? 'PUT' : 'POST'
        if (method === 'POST') {
            query = 'image_process'
        }

        // eslint-disable-next-line array-callback-return
        operations.rules.some((rule) => {
            if (typeof rule !== 'object') {
                throw new Error('[@cloudbase/extension-ci] WaterMark,rule必须为对象')
            }
        })

        // eslint-disable-next-line no-restricted-syntax
        for (const processRule of operations.rules) {
            const { rule } = processRule
            if ((rule.type === 1 || rule.type === 2) && rule.image) {
                if (rule.image.indexOf('/') === 0) {
                    rule.image = rule.image.slice(1)
                }

                processRule.rule = `watermark/${rule.mode}/type/${rule.type}/image/${rule.image}`
            } else if (rule.type === 3 && rule.text) {
                processRule.rule = `watermark/${rule.mode}/type/${rule.type}/text/${Base64.encode(rule.text).replace(/\//g, '_').replace(/=/g, '').replace(/\+/g, '-')}`
            } else {
                throw new Error('[@cloudbase/extension-ci] WaterMark,rule参数错误')
            }
        }
    }

    if (operations) {
        headers['Pic-Operations'] = JSON.stringify(operations)
    }

    const functionOpts = {
        name: 'tcb_extension_ci',
        data: {
            key: cloudPath,
            action,
            query: typeof query === 'object' ? query : null,
            headers,
            method
        }
    }

    const ciRes = await callFunction(tcb, functionOpts)

    // eslint-disable-next-line prefer-const
    let { authorization, token, url, headers: headerRes, cosFileId } = ciRes || {}

    let options
    if (method === 'PUT') {
        if (!cosFileId) {
            const metaDataRes = await tcb.getUploadMetadata({ cloudPath })
            cosFileId = metaDataRes.data.cosFileId
        }

        options = {
            url,
            headers: {
                ...headerRes,
                'x-cos-security-token': token,
                'x-cos-meta-fileid': cosFileId,
                Authorization: authorization
            },
            method,
            body: fileContent
        }
    } else {
        if (method === 'POST') {
            const fileIds = operations.rules.map((rule) => rule.fileid).filter((fileid) => !!fileid)
            if (fileIds && fileIds.length > 0) {
                let filePath = parsePath(cloudPath, fileIds[0])
                filePath = filePath.indexOf('/') === 0 ? filePath.slice(1) : filePath

                if (!cosFileId) {
                    const metaDataRes = await tcb.getUploadMetadata({ cloudPath: filePath })
                    cosFileId = metaDataRes.data.cosFileId
                }
            }
        }

        let newUrl
        let queryStr
        if (query && typeof query === 'object') {
            queryStr = Object.keys(query).map((key) => `${key}=${query[key]}`).join('&')
        } else if (query && typeof query === 'string') {
            queryStr = query
        }

        newUrl = url

        if (url.indexOf('?') > -1) {
            newUrl += `&${queryStr}`
        } else {
            newUrl += `?${queryStr}`
        }

        options = {
            url: newUrl,
            headers: {
                ...headerRes,
                Authorization: authorization,
                'x-cos-security-token': token
            },
            method: method.toUpperCase()
        }

        if (method === 'POST' && cosFileId) {
            options.headers['x-cos-meta-fileid'] = cosFileId
        }
    }

    const body = await tcb.requestClient[method.toLowerCase()](options)
    if (body && body.data) {
        const parseRes = parser.parse(body.data)
        if (parseRes && parseRes.UploadResult && parseRes.UploadResult.OriginalInfo && parseRes.UploadResult.OriginalInfo.Location) {
            parseRes.UploadResult.OriginalInfo.Location = parseRes.UploadResult.OriginalInfo.Location.replace(/cos\.ap-([a-z]+)\.myqcloud\.com/, 'tcb.qcloud.la')
        }

        if (parseRes && parseRes.UploadResult && parseRes.UploadResult.ProcessResults
            && parseRes.UploadResult.ProcessResults.Object && parseRes.UploadResult.ProcessResults.Object.Location
        ) {
            parseRes.UploadResult.ProcessResults.Object.Location = parseRes.UploadResult.ProcessResults.Object.Location.replace(/cos\.ap-([a-z]+)\.myqcloud\.com/, 'tcb.qcloud.la')
        }

        body.data = parseRes
    }

    return body
}
